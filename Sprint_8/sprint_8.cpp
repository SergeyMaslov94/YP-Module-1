// ТУТ ЕСТЬ ГЕНЕРАТОРЫ И БЕНЧМАРКИ!!!!

//#include "Topic_1/lesson_1.hpp"
//#include "Topic_1/lesson_2.hpp"
//#include "Topic_1/lesson_3.hpp"
//#include "Topic_1/lesson_4.hpp"
//#include "Topic_1/lesson_5.hpp"
//#include "Topic_1/lesson_6.hpp"
//#include "Topic_1/lesson_7.hpp"
//#include "Topic_1/lesson_8.hpp"

//#include "Topic_2/theory_1.hpp"
//#include "Topic_2/lesson_1.hpp"
//#include "Topic_2/lesson_2.hpp"
//#include "Topic_2/lesson_3.hpp"
//#include "Topic_2/lesson_4.hpp"
//#include "Topic_2/lesson_5.hpp"

//#include "Topic_3/lesson_1.hpp"
//#include "Topic_3/lesson_2.hpp"
#include "Topic_3/lesson_3.hpp"
//============================================
int main() {
	//============================================================================================================================
	// ТЕМА 1: ПАРАЛЛЕЛЬНЫЕ АЛГОРИТМЫ

	//lesson_1();  // применим макросы, чтобы измерить время последовательного и параллельного алгоритмов сортировки документов

	// TRANSFORM_REDUCE!!! execution::par!!!!!
	//lesson_2(); // паралельно расчитываем кол-во пробелов в строке используя стандартную функцию библиотек stl count(execution::par, str.begin(), str.end(), ' ') + 1;
			    // паралельно расчитываем кол-во пробелов в строке используя концепцию MapReduce
		
	// концепция MapReduce: transform и reduce
	// концепция MapReduce: transform_reduce
	//lesson_3(); 
		/*
		Map-стадия:
			Вход: набор символов строки;
			Операция: будет ли конкретный символ пробелом? Если да — 1. Если нет — 0;
			Выход: набор чисел 0 и 1, где 1 означает, что соответствующий символ — пробел.
		Reduce-стадия:
			Вход: набор чисел 0 и 1;
			Операция: сумма;
			Выход: количество единиц во входном наборе, то есть количество пробелов.
		*/

	// Scan-алгоритмы ЧТО-ТО ВРОДЕ ПАРАЛЛЕЛЬНОГО CUMSUM???
	/*
		inclusive_scan 
		возвращает первый элемент, сумму первых двух, первых трёх, 
		а последней — сумму всех. То есть i-я сумма включает в себя i-й элемент.

		 exclusive_scan 
		 возвращает начальный элемент (например, 0), первый, сумму
		 первых двух, а последней — сумму всех, кроме последнего. То есть i-я сумма
		 не включает i-й элемент.
	*/
	//lesson_4(); 

	// ПАРАЛЛЕЛИМ ЗАПРОСЫ К ПОИСКОВОЙ СИСТЕМЕ
	//lesson_5(); //process_queries
	//lesson_6(); //process_queries

	// ПАРАЛЛЕЛИМ МЕТОДЫ ПОИСКОВОЙ СИСТЕМЫ
	//lesson_7(); // SearchServer.RemoveDocument()
	//lesson_8(); // SearchServer.MatchDocument()

	//============================================================================================================================
	// ТЕМА 2: АССИНХРОННЫЕ ВЫЧИСЛЕНИЯ
	//theory_1();
	//lesson_1(); // ассинхронные вычисления
	//lesson_2(); // оособенности future
	//lesson_3(); // накладные расходы на вызов async
	//lesson_4(); // ускоряем for_each (урок 1)
	//lesson_5(); // ускоряем for_each (урок 2)
	// МНОГО ТЕКСТА!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	/*
	Начните с написания шаблонной функции ForEach, принимающей произвольные ExecutionPolicy, контейнер и функцию и вызывающей for_each. 
	Добавьте версию от двух параметров, вызывающую предыдущую с execution::seq.
	
	Теперь самый простой способ — добавить в основную версию ветвление следующего вида: «если тип ExecutionPolicy — это execution::par 
	и итераторы контейнера не обладают произвольным доступом, вызвать свою версию». Проблема в том, что в C++ типы — это не объекты: 
	их нельзя сравнивать на == и передавать их в функции. Зато типы могут быть параметрами шаблонов, поэтому будем использовать шаблонную 
	магию из библиотек <type_traits> и <iterator>.
	
	1. Чтобы проверить, что два типа совпадают, используйте is_same_v: is_same_v<ExecutionPolicy, execution::sequenced_policy>. 
	Если что-нибудь не работает, вероятно, тип ExecutionPolicy отличается от нужного лишь константностью или наличием ссылки. 
	В этом случае поможет обернуть его в decay_t: is_same_v<decay_t<ExecutionPolicy>, execution::sequenced_policy>. 
	Здесь is_same_v, это шаблонная булевская переменная, так что при подстановке в неё двух типов выражение is_same_v<T, U> имеет 
	тип bool и может участвовать в логических выражениях.
	
	2. Тип итератора для контейнера типа ForwardRange можно получить с помощью выражения typename ForwardRange::iterator. 
	В реальной жизни это не всегда так, и в авторском решении вы увидите более правильный подход.
	
	3. Получить категорию итератора типа It можно, использовав выражение typename iterator_traits<It>::iterator_category.
	
	4. Категория итератора — это некоторый тип, объекты которого вам точно не понадобится создавать. Вам нужен random_access_iterator_tag.
	
	5. Условие из этих кирпичиков можно поместить в оператор if: тогда при каждом вызове функции оно будет проверяться. 
	Но поскольку результат вычисления такого логического выражения зависит только от шаблонных параметров, его можно вычислить 
	ещё на этапе компиляции — и там же пойти в нужную ветку условного оператора. Для этого сразу после слова if добавьте слово constexpr. 
	Оно употребляется в разных контекстах, но всегда относится к вычислениям на этапе компиляции. Преимущество if constexpr не только 
	в эффективности: теперь в той ветке, в которую компилятор попадает только с итераторами произвольного доступа, можно спокойно 
	вычитать итераторы. С обычным if такой код не скомпилируется.
	*/
	//============================================================================================================================
	// ТЕМА 3: СОСТОЯНИЕ ГОНКИ И ЗАЩИТА ОТ НЕГО
	//lesson_1(); // mutex и lock_guard
	//lesson_2(); // О размере критической области
	lesson_3(); // О размере критической области. Ускоряем copy_if
	return 0;
}
